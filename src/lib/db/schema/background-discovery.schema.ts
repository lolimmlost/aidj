/**
 * Background Discovery Schema
 *
 * Stores suggestions generated by the background discovery system,
 * rejection history to prevent re-suggesting dismissed items,
 * and job state for the background scheduler.
 *
 * Features:
 * - Discovery suggestions with approval workflow
 * - Rejection history with expiration (can re-suggest after 30 days)
 * - Job state tracking with failure handling
 */

import { pgTable, text, timestamp, integer, real, index, unique, jsonb, boolean } from "drizzle-orm/pg-core";
import { user } from "./auth.schema";

/**
 * Source types for discovery suggestions
 */
export type DiscoverySource = 'similar_track' | 'artist_top_track' | 'genre_based';

/**
 * Status of a discovery suggestion
 */
export type SuggestionStatus = 'pending' | 'approved' | 'rejected' | 'dismissed';

/**
 * Discovery Suggestions
 * Tracks music discovered by the background system awaiting user approval
 */
export const discoverySuggestions = pgTable("discovery_suggestions", {
  id: text("id").primaryKey().$defaultFn(() => crypto.randomUUID()),

  userId: text("user_id")
    .notNull()
    .references(() => user.id, { onDelete: "cascade" }),

  // Track identification
  artistName: text("artist_name").notNull(),
  trackName: text("track_name").notNull(),
  albumName: text("album_name"),

  // Source information
  source: text("source", { enum: ['similar_track', 'artist_top_track', 'genre_based'] }).notNull(),
  seedArtist: text("seed_artist").notNull(),      // Library artist that led to this suggestion
  seedTrack: text("seed_track"),                   // Library track that led to this suggestion

  // Scoring
  matchScore: real("match_score").default(0).notNull(),  // 0-1 from Last.fm similarity

  // Status tracking
  status: text("status", { enum: ['pending', 'approved', 'rejected', 'dismissed'] }).default('pending').notNull(),

  // Metadata
  lastFmUrl: text("lastfm_url"),
  imageUrl: text("image_url"),
  genres: jsonb("genres").$type<string[]>().default([]).notNull(),
  explanation: text("explanation"),  // "Similar to Karma Police by Radiohead"

  // Timestamps
  suggestedAt: timestamp("suggested_at")
    .$defaultFn(() => new Date())
    .notNull(),
  reviewedAt: timestamp("reviewed_at"),
}, (table) => ({
  // Index for user pending suggestions
  userStatusIdx: index("discovery_suggestions_user_status_idx").on(table.userId, table.status),

  // Index for duplicate checking
  userArtistTrackIdx: index("discovery_suggestions_user_artist_track_idx").on(
    table.userId,
    table.artistName,
    table.trackName
  ),

  // Index for sorting by score
  matchScoreIdx: index("discovery_suggestions_match_score_idx").on(table.matchScore),

  // Index for seed-based queries
  seedArtistIdx: index("discovery_suggestions_seed_artist_idx").on(table.seedArtist),
}));

/**
 * Discovery Rejection History
 * Prevents re-suggesting tracks the user has rejected
 * Entries expire after 30 days to allow re-discovery
 */
export const discoveryRejectionHistory = pgTable("discovery_rejection_history", {
  id: text("id").primaryKey().$defaultFn(() => crypto.randomUUID()),

  userId: text("user_id")
    .notNull()
    .references(() => user.id, { onDelete: "cascade" }),

  // Track identification (normalized lowercase for matching)
  artistName: text("artist_name").notNull(),
  trackName: text("track_name").notNull(),

  // Timestamps
  rejectedAt: timestamp("rejected_at")
    .$defaultFn(() => new Date())
    .notNull(),
  expiresAt: timestamp("expires_at")
    .$defaultFn(() => {
      const date = new Date();
      date.setDate(date.getDate() + 30);  // Can re-suggest after 30 days
      return date;
    })
    .notNull(),
}, (table) => ({
  // Unique constraint: one rejection per user-artist-track
  uniqueRejection: unique("discovery_rejection_unique").on(
    table.userId,
    table.artistName,
    table.trackName
  ),

  // Index for expiration cleanup
  expiresAtIdx: index("discovery_rejection_expires_at_idx").on(table.expiresAt),

  // Index for checking if track is rejected
  userArtistTrackIdx: index("discovery_rejection_user_artist_track_idx").on(
    table.userId,
    table.artistName,
    table.trackName
  ),
}));

/**
 * Discovery Job State
 * Tracks the state of the background discovery scheduler per user
 */
export const discoveryJobState = pgTable("discovery_job_state", {
  // Primary key is userId (one job state per user)
  userId: text("user_id")
    .primaryKey()
    .references(() => user.id, { onDelete: "cascade" }),

  // Job configuration
  enabled: boolean("enabled").default(true).notNull(),
  frequencyHours: integer("frequency_hours").default(12).notNull(),
  maxSuggestionsPerRun: integer("max_suggestions_per_run").default(15).notNull(),
  seedCount: integer("seed_count").default(10).notNull(),

  // Run tracking
  lastRunAt: timestamp("last_run_at"),
  nextRunAt: timestamp("next_run_at"),
  isRunning: boolean("is_running").default(false).notNull(),

  // Failure handling
  consecutiveFailures: integer("consecutive_failures").default(0).notNull(),
  lastError: text("last_error"),

  // Statistics
  totalSuggestionsGenerated: integer("total_suggestions_generated").default(0).notNull(),
  totalApproved: integer("total_approved").default(0).notNull(),
  totalRejected: integer("total_rejected").default(0).notNull(),

  // Timestamps
  createdAt: timestamp("created_at")
    .$defaultFn(() => new Date())
    .notNull(),
  updatedAt: timestamp("updated_at")
    .$defaultFn(() => new Date())
    .notNull(),
}, (table) => ({
  // Index for finding jobs due to run
  nextRunAtIdx: index("discovery_job_state_next_run_at_idx").on(table.nextRunAt),

  // Index for enabled jobs
  enabledIdx: index("discovery_job_state_enabled_idx").on(table.enabled),
}));

// Type exports
export type DiscoverySuggestion = typeof discoverySuggestions.$inferSelect;
export type DiscoverySuggestionInsert = typeof discoverySuggestions.$inferInsert;

export type DiscoveryRejectionHistory = typeof discoveryRejectionHistory.$inferSelect;
export type DiscoveryRejectionHistoryInsert = typeof discoveryRejectionHistory.$inferInsert;

export type DiscoveryJobState = typeof discoveryJobState.$inferSelect;
export type DiscoveryJobStateInsert = typeof discoveryJobState.$inferInsert;
